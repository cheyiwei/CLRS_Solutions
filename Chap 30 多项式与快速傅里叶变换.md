# Chap 30 多项式与快速傅里叶变换

标签（空格分隔）： 算法导论

---

#30.1 多项式与快速傅里叶变换

##本节内容概括

本章FFT是20世纪经典十大算法之一，通过一种绕路（系数转换为点值）方法，实现更快的求解，FFT和IFFT本质上是一种点值系数互相转换的方法，在$\Theta(n\log n)$时间内完成

##练习
###30.1-1
略
###30.1-3
先逆FFT再FFT？
#30.2 DFT和FFT
##本节内容概括
介绍了单位负数根，其中根据消去引理和折半引理（重要），可以通过n/2个n/2次的单位根的集合等于n个n次单位复数根的集合

其中DFT就是求单位复数根的0~n-1次幂对应的点值集合

FFT正是应用到了折半引理，采用分治的方法，使时间复杂度降至$\Theta(n \log n)$

```c
RECUSIVE_FFT(a)
n=a.length
if n=1
    return a
w_n=e^{2*pi*i/n}
w=1
a_0 = (a_0,a_2,a_4,...,a_{n-1})
a_1 = (a_1,a_3,...,a_n)
y_0 = RECUSIVE_FFT(a_0)
y_1 = RECUSIVE_FFT(a_1)
for i=0 to [2/n]-1
    y[i] = y_0[i] + w*y_1[i]
    y[i+n/2] = y_0[i] - w*y_1[i]
    w=w*w_n
return y
```

##练习
###30.2-2
$(0,1,2,3)$
$w_n ^ 0 = 1$
$w_n ^ 1 = i$
$w_n ^ 2 = -1$
$w_n ^ 3 = -i$
$y[0] = 0*1 + 1*1+2*1+3*1=6$
$y[1] = 0*1 + 1*i + 2*(-1) + 3*(-i) = -2-2i$
$y[2] = 0*1 + 1*(-1) + 2*(1) + 3*(-1) = -2$
$y[3] = 0*1 - 1*i + 2*(-1) + 3*(i) = -2+2i$

#30.3  高效的FFT
##本章内容概括
本章介绍了一种高效的FFT实现，具体采用了迭代+蝴蝶操作，注意计算时的次序应该是二进制bit位的逆序，而且采用自底向上的填表方式
```c
ITERATIVE_FFT(a)
BIT_RECEIVE_COPY(a,A)//逆序
n=a.length
for s=1 to lgn
    m=2^s
    w_n = e^{2*pi*i/m}
    for i=0 to n -1 by m
        w=1
        for j=0 to m/2-1
            t=w*A[k+j+m/2]
            u=A[k+j]
            A[k+j]=u+t
            A[k+j+m/2]=u-t
            w=w*w_n
return A
```




